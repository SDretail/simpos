{
  "version": 3,
  "sources": ["../../onscan.js/onscan.js"],
  "sourcesContent": ["/*\n * onScan.js - scan-events for hardware barcodes scanners in javascript\n */\n;(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory()) :\n    global.onScan = factory()\n}(this, (function () {\n\tvar onScan = {\t\n\t\t\n\t\t/**\n\t\t * \n\t\t * @param DomElement oDomElement\n\t\t * @param Object oOptions\n\t\t * @return self\n\t\t */\n\t\tattachTo: function(oDomElement, oOptions) {\n\t\n\t\t\tif(oDomElement.scannerDetectionData !== undefined){\n\t\t\t\tthrow new Error(\"onScan.js is already initialized for DOM element \" + oDomElement);\n\t\t\t}\n\t\n\t\t\tvar oDefaults = {\n\t\t\t\tonScan: function(sScanned, iQty){}, // Callback after detection of a successfull scanning:  function(){sScancode, iCount)}()\n\t\t\t\tonScanError: function(oDebug){}, // Callback after detection of a unsuccessfull scanning (scanned string in parameter)\n\t\t\t\tonKeyProcess: function(sChar, oEvent){}, // Callback after receiving and processing a char (scanned char in parameter)\n\t\t\t\tonKeyDetect: function(iKeyCode, oEvent){}, // Callback after detecting a keyDown (key char in parameter) - in contrast to onKeyProcess, this fires for non-character keys like tab, arrows, etc. too!\n\t\t\t\tonPaste: function(sPasted, oEvent){}, // Callback after receiving a value on paste, no matter if it is a valid code or not\n\t\t\t\tkeyCodeMapper: function(oEvent) {return onScan.decodeKeyEvent(oEvent)}, // Custom function to decode a keydown event into a character. Must return decoded character or NULL if the given event should not be processed.\n\t\t\t\tonScanButtonLongPress: function(){}, // Callback after detection of a successfull scan while the scan button was pressed and held down\n\t\t\t\tscanButtonKeyCode:false, // Key code of the scanner hardware button (if the scanner button a acts as a key itself) \n\t\t\t\tscanButtonLongPressTime:500, // How long (ms) the hardware button should be pressed, until a callback gets executed\n\t\t\t\ttimeBeforeScanTest:100, // Wait duration (ms) after keypress event to check if scanning is finished\n\t\t\t\tavgTimeByChar:30, // Average time (ms) between 2 chars. Used to do difference between keyboard typing and scanning\n\t\t\t\tminLength:6, // Minimum length for a scanning\n\t\t\t\tsuffixKeyCodes:[9,13], // Chars to remove and means end of scanning\n\t\t\t\tprefixKeyCodes:[], // Chars to remove and means start of scanning\n\t\t\t\tignoreIfFocusOn:false, // do not handle scans if the currently focused element matches this selector or object\n\t\t\t\tstopPropagation:false, // Stop immediate propagation on keypress event\n\t\t\t\tpreventDefault:false, // Prevent default action on keypress event\n\t\t\t\tcaptureEvents:false, // Get the events before any listeners deeper in the DOM\n\t\t\t\treactToKeydown:true, // look for scan input in keyboard events\n\t\t\t\treactToPaste:false, // look for scan input in paste events\n\t\t\t\tsingleScanQty: 1, // Quantity of Items put out to onScan in a single scan\n\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\toOptions = this._mergeOptions(oDefaults, oOptions);\n\t\n\t\t\t// initializing options and variables on DomElement\n\t\t\toDomElement.scannerDetectionData = {\n\t\t\t\t\toptions: oOptions,\n\t\t\t\t\tvars:{\n\t\t\t\t\t\tfirstCharTime: 0,\n\t\t\t\t\t\tlastCharTime: 0,\n\t\t\t\t\t\taccumulatedString: '',\n\t\t\t\t\t\ttestTimer: false,\n\t\t\t\t\t\tlongPressTimeStart: 0,\n\t\t\t\t\t\tlongPressed: false\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t};\n\t\t\t\n\t\t\t// initializing handlers (based on settings)\n\t\t\tif (oOptions.reactToPaste === true){\n\t\t\t\toDomElement.addEventListener(\"paste\", this._handlePaste, oOptions.captureEvents);\n\t\t\t}\n\t\t\tif (oOptions.scanButtonKeyCode !== false){\n\t\t\t\toDomElement.addEventListener(\"keyup\", this._handleKeyUp, oOptions.captureEvents);\n\t\t\t}\n\t\t\tif (oOptions.reactToKeydown === true || oOptions.scanButtonKeyCode !== false){\t\n\t\t\t\toDomElement.addEventListener(\"keydown\", this._handleKeyDown, oOptions.captureEvents);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\t\n\t\t/**\n\t\t * \n\t\t * @param DomElement oDomElement\n\t\t * @return void\n\t\t */\n\t\tdetachFrom: function(oDomElement) {\n\t\t\t// detaching all used events\n\t\t\tif (oDomElement.scannerDetectionData.options.reactToPaste){\n\t\t\t\toDomElement.removeEventListener(\"paste\", this._handlePaste);\n\t\t\t}\n\t\t\tif (oDomElement.scannerDetectionData.options.scanButtonKeyCode !== false){\n\t\t\t\toDomElement.removeEventListener(\"keyup\", this._handleKeyUp);\n\t\t\t}\n\t\t\toDomElement.removeEventListener(\"keydown\", this._handleKeyDown);\n\t\t\t\n\t\t\t// clearing data off DomElement\n\t\t\toDomElement.scannerDetectionData = undefined; \n\t\t\treturn;\n\t\t},\n\t\t\n\t\t/**\n\t\t * \n\t\t * @param DomElement oDomElement\n\t\t * @return Object\n\t\t */\n\t\tgetOptions: function(oDomElement){\n\t\t\treturn oDomElement.scannerDetectionData.options;\t\t\t\n\t\t},\n\t\n\t\t/**\n\t\t * \n\t\t * @param DomElement oDomElement\n\t\t * @param Object oOptions\n\t\t * @return self\n\t\t */\n\t\tsetOptions: function(oDomElement, oOptions){\n\t\t\t// check if some handlers need to be changed based on possible option changes\n\t\t\tswitch (oDomElement.scannerDetectionData.options.reactToPaste){\n\t\t\t\tcase true: \n\t\t\t\t\tif (oOptions.reactToPaste === false){\n\t\t\t\t\t\toDomElement.removeEventListener(\"paste\", this._handlePaste);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase false:\n\t\t\t\t\tif (oOptions.reactToPaste === true){\n\t\t\t\t\t\toDomElement.addEventListener(\"paste\", this._handlePaste);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tswitch (oDomElement.scannerDetectionData.options.scanButtonKeyCode){\n\t\t\t\tcase false:\n\t\t\t\t\tif (oOptions.scanButtonKeyCode !== false){\n\t\t\t\t\t\toDomElement.addEventListener(\"keyup\", this._handleKeyUp);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault: \n\t\t\t\t\tif (oOptions.scanButtonKeyCode === false){\n\t\t\t\t\t\toDomElement.removeEventListener(\"keyup\", this._handleKeyUp);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t// merge old and new options\n\t\t\toDomElement.scannerDetectionData.options = this._mergeOptions(oDomElement.scannerDetectionData.options, oOptions);\n\t\t\n\t\t\t// reinitiallize\n\t\t\tthis._reinitialize(oDomElement);\n\t\t\treturn this;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Transforms key codes into characters.\n\t\t * \n\t\t * By default, only the follwing key codes are taken into account\n\t\t * - 48-90 (letters and regular numbers)\n\t\t * - 96-105 (numeric keypad numbers)\n\t\t * - 106-111 (numeric keypad operations)\n\t\t * \n\t\t * All other keys will yield empty strings!\n\t\t * \n\t\t * The above keycodes will be decoded using the KeyboardEvent.key property on modern\n\t\t * browsers. On older browsers the method will fall back to String.fromCharCode()\n\t\t * putting the result to upper/lower case depending on KeyboardEvent.shiftKey if\n\t\t * it is set.\n\t\t * \n\t\t * @param KeyboardEvent oEvent\n\t\t * @return string\n\t\t */\n\t\tdecodeKeyEvent : function (oEvent) {\n\t\t\tvar iCode = this._getNormalizedKeyNum(oEvent);\n\t\t\tswitch (true) {\n\t\t\t\tcase iCode >= 48 && iCode <= 90: // numbers and letters\n\t\t\t\tcase iCode >= 106 && iCode <= 111: // operations on numeric keypad (+, -, etc.)\n\t\t\t\t\tif (oEvent.key !== undefined && oEvent.key !== '') {\n\t\t\t\t\t\treturn oEvent.key;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tvar sDecoded = String.fromCharCode(iCode);\n\t\t\t\t\tswitch (oEvent.shiftKey) {\n\t\t\t\t\t\tcase false: sDecoded = sDecoded.toLowerCase(); break;\n\t\t\t\t\t\tcase true: sDecoded = sDecoded.toUpperCase(); break;\n\t\t\t\t\t}\n\t\t\t\t\treturn sDecoded;\n\t\t\t\tcase iCode >= 96 && iCode <= 105: // numbers on numeric keypad\n\t\t\t\t\treturn 0+(iCode-96);\n\t\t\t}\n\t\t\treturn '';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Simulates a scan of the provided code.\n\t     *\n\t\t * The scan code can be defined as\n\t\t * - a string - in this case no keyCode decoding is done and the code is merely validated\n\t\t * against constraints like minLenght, etc.\n\t\t * - an array of keyCodes (e.g. `[70,71,80]`) - will produce `keydown` events with corresponding\n\t\t * `keyCode` properties. NOTE: these events will have empty `key` properties, so decoding may\n\t\t * yield different results than with native events.\n\t\t * - an array of objects (e.g. `[{keyCode: 70, key: \"F\", shiftKey: true}, {keyCode: 71, key: \"g\"}]`) -\n\t\t * this way almost any event can be simulated, but it's a lot of work to do.\n\t\t *\n\t\t * @param DomElement oDomElement\n\t\t * @param string|array mStringOrArray\n\t\t * @return self\n\t\t */\n\t\tsimulate: function(oDomElement, mStringOrArray){\n\t\t\tthis._reinitialize(oDomElement);\n\t\t\tif (Array.isArray(mStringOrArray)){\n\t\t\t\tmStringOrArray.forEach(function(mKey){\n\t\t\t\t\tvar oEventProps = {};\n\t\t\t\t\tif( (typeof mKey === \"object\" || typeof mKey === 'function') && (mKey !== null) ) {\n\t\t\t\t\t\toEventProps = mKey;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toEventProps.keyCode = parseInt(mKey);\n\t\t\t\t\t}\n\t\t\t\t\tvar oEvent = new KeyboardEvent('keydown', oEventProps);\n\t\t\t\t\tdocument.dispatchEvent(oEvent);\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tthis._validateScanCode(oDomElement, mStringOrArray);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\t\n\t\t/**\n\t\t * @private\n\t\t * @param DomElement oDomElement\n\t\t * @return void\n\t\t */\n\t\t_reinitialize: function(oDomElement){\n\t\t\tvar oVars = oDomElement.scannerDetectionData.vars;\n\t\t\toVars.firstCharTime = 0;\n\t\t\toVars.lastCharTime = 0;\n\t\t\toVars.accumulatedString = '';\n\t\t\treturn;\n\t\t},\n\t\t\n\t\t/**\n\t\t * @private\n\t\t * @param DomElement oDomElement\n\t     * @return boolean\n\t\t */\n\t\t_isFocusOnIgnoredElement: function(oDomElement){\n\t\t\t\n\t\t\tvar ignoreSelectors = oDomElement.scannerDetectionData.options.ignoreIfFocusOn;\n\t\n\t        if(!ignoreSelectors){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\n\t\t\tvar oFocused = document.activeElement;\n\t\t\t\n\t\t\t// checks if ignored element is an array, and if so it checks if one of the elements of it is an active one\n\t\t\tif (Array.isArray(ignoreSelectors)){\n\t\t\t\tfor(var i=0; i<ignoreSelectors.length; i++){\n\t\t\t\t\tif(oFocused.matches(ignoreSelectors[i]) === true){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t// if the option consists of an single element, it only checks this one\n\t\t\t} else if (oFocused.matches(ignoreSelectors)){\n\t\t\t\treturn true;\t\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// if the active element is not listed in the ignoreIfFocusOn option, return false\n\t\t    return false;\n\t    },\n\t\t\n\t    /**\n\t     * Validates the scan code accumulated by the given DOM element and fires the respective events.\n\t     * \n\t     * @private\n\t     * @param DomElement oDomElement\n\t     * @return boolean\n\t     */\n\t\t_validateScanCode: function(oDomElement, sScanCode){\n\t\t\tvar oScannerData = oDomElement.scannerDetectionData;\t\t\t\n\t\t\tvar oOptions = oScannerData.options;\n\t\t\tvar iSingleScanQty = oScannerData.options.singleScanQty;\n\t\t\tvar iFirstCharTime = oScannerData.vars.firstCharTime;\n\t\t\tvar iLastCharTime = oScannerData.vars.lastCharTime;\n\t\t\tvar oScanError = {};\n\t        var oEvent;\n\t        \n\t\t\tswitch(true){\n\t\t\t\t\n\t\t\t\t// detect codes that are too short\n\t\t\t\tcase (sScanCode.length < oOptions.minLength):\n\t\t\t\t\toScanError = {\n\t\t\t\t\t\tmessage: \"Receieved code is shorter then minimal length\"\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t// detect codes that were entered too slow\t\n\t\t\t\tcase ((iLastCharTime - iFirstCharTime) > (sScanCode.length * oOptions.avgTimeByChar)):\n\t\t\t\t\toScanError = {\n\t\t\t\t\t\tmessage: \"Receieved code was not entered in time\"\n\t\t\t\t\t};\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t// if a code was not filtered out earlier it is valid\t\n\t\t\t\tdefault:\n\t\t\t\t\toOptions.onScan.call(oDomElement, sScanCode, iSingleScanQty);\n\t\t\t\t\toEvent = new CustomEvent(\n\t\t\t\t\t\t'scan',\n\t\t\t\t\t\t{\t\n\t\t\t\t\t\t\tdetail: { \n\t\t\t\t\t\t\t\tscanCode: sScanCode,\n\t\t\t\t\t\t\t\tqty: iSingleScanQty\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t\toDomElement.dispatchEvent(oEvent);\n\t\t\t\t\tonScan._reinitialize(oDomElement);\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\t// If an error occurred (otherwise the method would return earlier) create an object for errordetection\n\t\t\toScanError.scanCode = sScanCode;\n\t\t\toScanError.scanDuration = iLastCharTime - iFirstCharTime;\n\t\t\toScanError.avgTimeByChar = oOptions.avgTimeByChar;\n\t\t\toScanError.minLength = oOptions.minLength;\n\t\t\t\n\t\t\toOptions.onScanError.call(oDomElement, oScanError);\n\t\t\t\n\t\t\toEvent = new CustomEvent(\n\t\t\t\t'scanError', \n\t\t\t\t{detail: oScanError}\n\t\t\t);\n\t\t\toDomElement.dispatchEvent(oEvent);\n\t\t\t\n\t\t\tonScan._reinitialize(oDomElement);\n\t\t\treturn false;\n\t    },\n\t\n\t    /**\n\t     * @private\n\t     * @param Object oDefaults\n\t     * @param Object oOptions\n\t     * @return Object\n\t     */\n\t\t_mergeOptions: function(oDefaults, oOptions){\n\t\t\tvar oExtended = {};\n\t\t\tvar prop;\n\t\t\tfor (prop in oDefaults){\n\t\t\t\tif (Object.prototype.hasOwnProperty.call(oDefaults, prop)){\n\t\t\t\t\toExtended[prop] = oDefaults[prop];\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t\tfor (prop in oOptions){\n\t\t\t\tif (Object.prototype.hasOwnProperty.call(oOptions, prop)){\n\t\t\t\t\toExtended[prop] = oOptions[prop];\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t\treturn oExtended;\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t * @param KeyboardEvent e\n\t\t * @return int\n\t\t * @see https://www.w3schools.com/jsref/event_key_keycode.asp\n\t\t */\n\t\t_getNormalizedKeyNum: function(e){\n\t\t\treturn e.which || e.keyCode;\n\t\t},\n\t\n\t\n\t\t/**\n\t\t * @private\n\t\t * @param KeyboardEvent e\n\t\t * @return void\n\t\t */\n\t\t_handleKeyDown: function(e){\n\t\t\tvar iKeyCode = onScan._getNormalizedKeyNum(e);\n\t\t\tvar oOptions = this.scannerDetectionData.options;\n\t\t\tvar oVars = this.scannerDetectionData.vars;\n\t\t\tvar bScanFinished = false;\n\t\t\t\n\t\t\tif (oOptions.onKeyDetect.call(this, iKeyCode, e) === false) {\n\t\t\t\treturn;\n\t\t\t}\t\t\n\t\t\t\n\t\t\tif (onScan._isFocusOnIgnoredElement(this)){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\t\t\t\n\t        // If it's just the button of the scanner, ignore it and wait for the real input\n\t\t    if(oOptions.scanButtonKeyCode !== false && iKeyCode==oOptions.scanButtonKeyCode) {\n\t\t\t\t\n\t\t\t\t// if the button was first pressed, start a timeout for the callback, which gets interrupted if the scanbutton gets released\n\t\t\t\tif (!oVars.longPressed){\n\t\t\t\t\toVars.longPressTimer = setTimeout( oOptions.onScanButtonLongPress, oOptions.scanButtonLongPressTime, this);\n\t\t\t\t\toVars.longPressed = true;\n\t\t\t\t}\n\t\n\t\t\t\treturn;\n\t        }\n\t\t\t\n\t\t\tswitch(true){\n\t\t\t\t// If it's not the first character and we encounter a terminating character, trigger scan process\n\t\t\t\tcase (oVars.firstCharTime && oOptions.suffixKeyCodes.indexOf(iKeyCode)!==-1):\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\te.stopImmediatePropagation();\n\t\t\t\t\tbScanFinished=true;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t// If it's the first character and we encountered one of the starting characters, don't process the scan\t\n\t\t\t\tcase (!oVars.firstCharTime && oOptions.prefixKeyCodes.indexOf(iKeyCode)!==-1):\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\te.stopImmediatePropagation();\n\t\t\t\t\tbScanFinished=false;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t// Otherwise, just add the character to the scan string we're building\t\n\t\t\t\tdefault:\n\t\t\t\t\tvar character = oOptions.keyCodeMapper.call(this, e);\n\t\t\t\t\tif (character === null){\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\toVars.accumulatedString += character;\n\t\t\t\t\t\n\t\t\t\t\tif (oOptions.preventDefault) {\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t}\n\t\t\t\t\tif (oOptions.stopPropagation) {\n\t\t\t\t\t\te.stopImmediatePropagation();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tbScanFinished=false;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t        \n\t\t\tif(!oVars.firstCharTime){\n\t\t\t\toVars.firstCharTime=Date.now();\n\t\t\t}\n\t\t\t\n\t\t\toVars.lastCharTime=Date.now();\n\t\n\t\t\tif(oVars.testTimer){ \n\t\t\t\tclearTimeout(oVars.testTimer);\n\t\t\t}\n\t\t\t\n\t\t\tif(bScanFinished){\n\t\t\t\tonScan._validateScanCode(this, oVars.accumulatedString);\n\t\t\t\toVars.testTimer=false;\n\t\t\t} else {\n\t\t\t\toVars.testTimer=setTimeout(onScan._validateScanCode, oOptions.timeBeforeScanTest, this, oVars.accumulatedString);\n\t\t\t}\n\t\n\t\t\toOptions.onKeyProcess.call(this, character, e);\n\t\t\treturn;\n\t\t},\n\t\t\n\t\t/**\n\t\t * @private\n\t\t * @param Event e\n\t\t * @return void\n\t\t */\n\t\t_handlePaste: function(e){\n\t\n\t\t\tvar oOptions = this.scannerDetectionData.options;\n\t\t\tvar oVars = this.scannerDetectionData.vars;\n\t\t\tvar sPasteString = (event.clipboardData || window.clipboardData).getData('text');\n\t\t\t\n\t\t\t// if the focus is on an ignored element, abort\n\t\t\tif (onScan._isFocusOnIgnoredElement(this)){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\te.preventDefault();\n\n\t\t\tif (oOptions.stopPropagation) {\n\t\t\t\te.stopImmediatePropagation();\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\toOptions.onPaste.call(this, sPasteString, event);\n\t\t\t\n\t\t\toVars.firstCharTime = 0;\n\t\t\toVars.lastCharTime = 0;\n\t\t\t\n\t\t\t// validate the string\n\t\t\tonScan._validateScanCode(this, sPasteString);\n\t\t\treturn;\n\t\t},\n\t\t\n\t\t/**\n\t\t * @private\n\t\t * @param KeyboardEvent e\n\t\t * @return void\n\t\t */\n\t\t_handleKeyUp: function(e){\n\t\t\t// if the focus is on an ignored element, abort\n\t\t\tif (onScan._isFocusOnIgnoredElement(this)){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tvar iKeyCode = onScan._getNormalizedKeyNum(e);\n\t\t\t\n\t\t\t// if hardware key is not being pressed anymore stop the timeout and reset\n\t\t\tif (iKeyCode == this.scannerDetectionData.options.scanButtonKeyCode){\n\t\t\t\tclearTimeout(this.scannerDetectionData.vars.longPressTimer);\n\t\t\t\tthis.scannerDetectionData.vars.longPressed = false;\n\t\t\t}\n\t\t\treturn;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns TRUE the scanner is currently in the middle of a scan sequence.\n\t\t * \n\t\t * @param DomElement\n\t\t * @return boolean\n\t\t */\n\t\tisScanInProgressFor: function(oDomElement) {\n\t\t\treturn oDomElement.scannerDetectionData.vars.firstCharTime > 0;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns TRUE if onScan is attached to the given DOM element and FALSE otherwise.\n\t\t * \n\t\t * @param DomElement\n\t\t * @return boolean\n\t\t */\n\t\tisAttachedTo: function(oDomElement) {\n\t\t\treturn (oDomElement.scannerDetectionData !== undefined);\n\t\t}\n\t};\n\t\n\treturn onScan;\n})));"],
  "mappings": "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",
  "names": []
}
